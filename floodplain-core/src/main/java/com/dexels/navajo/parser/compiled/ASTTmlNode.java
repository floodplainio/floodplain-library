/* Generated By:JJTree&JavaCC: Do not edit this line. ASTTmlNode.java */
package com.dexels.navajo.parser.compiled;

import com.dexels.immutable.api.ImmutableMessage;
import com.dexels.immutable.api.ImmutableMessage.ValueType;
import com.dexels.immutable.factory.ImmutableFactory;
import com.dexels.navajo.document.operand.ClockTime;
import com.dexels.navajo.document.operand.Operand;
import com.dexels.navajo.expression.api.ContextExpression;
import com.dexels.navajo.expression.api.FunctionClassification;
import com.dexels.navajo.expression.api.TMLExpressionException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.function.Function;

/**
 *
 * <p>Title: Navajo Product Project</p>
 * <p>Description: This is the official source for the Navajo server</p>
 * <p>Copyright: Copyright (c) 2002</p>
 * <p>Company: Dexels BV</p>
 * @author Arjen Schoneveld
 * @version $Id$
 */
final class ASTTmlNode extends SimpleNode {
    String val = "";
    String option = "";
    String selectionOption = "";
    boolean exists = false;
    
    
	private final static Logger logger = LoggerFactory.getLogger(ASTTmlNode.class);

    
    ASTTmlNode(int id) {
        super(id);
    }

    @Override
	public final ContextExpression interpretToLambda(List<String> problems, String expression, Function<String, FunctionClassification> functionClassifier, Function<String,Optional<Node>> mapResolver) {
		return new ContextExpression() {
	
			@Override
			public boolean isLiteral() {
				return false;
			}
			
			@Override
			public Operand apply(Optional<ImmutableMessage> immutableMessage, Optional<ImmutableMessage> paramMessage) {
//				List<Property> match = new ArrayList<>();
//				List<Object> resultList = new ArrayList<>();
		        boolean singleMatch = true;
		        if(val.equals("[") || val.equals("[/")) {
		        	return immutableMessage.map(msg->Operand.ofImmutable(msg)).orElse(Operand.NULL);
		        }
				if(val.equals("[/@")) {
					return paramMessage.map(msg->Operand.ofImmutable(msg)).orElse(Operand.NULL);
				}
		        String parts[] = val.split("\\|");
		        String text = parts.length > 1 ? parts[1] : val;
		        boolean isParam = false;
		        if (!exists) {
					if(text.startsWith("[")) {
			            text = text.substring(1, text.length());
					}
		        }  else {
					if(text.startsWith("?[")) {
			            text = text.substring(2, text.length());
					}
		        }
		        if (text.length() > 0 && text.charAt(0) == '@') { // relative param property.
		        		isParam = true;
		        		text = text.substring(1);
		        }
		        

		        if (isRegularExpression(text))
		            singleMatch = false;
		        else
		            singleMatch = true;

		        try {
		        		if(!isParam && immutableMessage!=null && immutableMessage.isPresent()) {
		        			ImmutableMessage rm = immutableMessage.get();
		        			return parseImmutablePath(text, rm);
		        		}
		        		if(isParam && paramMessage!=null && paramMessage.isPresent()) {
		        			ImmutableMessage rm = paramMessage.get();
		        			return parseImmutablePath(text, rm);
		        			
		        		}

		        } catch (Throwable te) {
		            throw new TMLExpressionException("Error resolving tml",te);
		        }
		        if (!singleMatch)
		            throw new TMLExpressionException("Property does not exist: " + text);
		        else
		            return Operand.FALSE;
			}

			private Operand parseImmutablePath(String text, ImmutableMessage rm) {
				if("".equals(text) || "/@".equals(text)) {
					return Operand.ofImmutable(rm);
				}
				if(text.endsWith("/")) {
					String trunc = text.substring(0,text.length()-1);
					List<String> parts = Arrays.asList(trunc.split("/"));
					return parseImmutableMessagePath(parts, rm);
				}
				List<String> parts = Arrays.asList(text.split("/"));
				return parseImmutablePath(parts, rm);
			}

			private Operand parseImmutableMessagePath(List<String> path, ImmutableMessage rm) {
				if(path.isEmpty()) {
					return Operand.ofImmutable(rm);
				}
				String first = path.get(0);
				Optional<ImmutableMessage> sub = rm.subMessage(first);
				if(sub.isPresent()) {
					List<String> copy = new ArrayList<>(path);
					copy.remove(0);
					return parseImmutableMessagePath(copy, sub.get());
				}
				Optional<List<ImmutableMessage>> subList = rm.subMessages(first);
				if(subList.isPresent()) {
					return Operand.ofImmutableList(subList.get());
				}
				logger.error("Submessage issue for path: {} with message: {}", path, ImmutableFactory.getInstance().describe(rm));
				throw new TMLExpressionException("Missing submessage: "+first+" with path list: "+path);
			}

			private Operand parseImmutablePath(List<String> path, ImmutableMessage rm) {
				if(path.size()>1) {
					Optional<ImmutableMessage> imm = rm.subMessage(path.get(0));
					if(imm.isPresent()) {
						List<String> parts = new LinkedList<>(path);
						parts.remove(0);
						return parseImmutablePath(parts,imm.get());
					}
					return null;
				}
				ValueType type = rm.columnType(path.get(0));
				if(type!=null) {
					return Operand.ofCustom(rm.value(path.get(0)).orElse(null), type);
				}
				return Operand.ofDynamic(rm.value(path.get(0)).orElse(null));
			}

			
			@Override
			public Optional<ValueType> returnType() {
				return Optional.empty();
			}
			
			@Override
			public String expression() {
				return expression;
			}
		};
	}

	public static final String MESSAGE_SEPARATOR = "/";
	public static final String PARENT_MESSAGE = "..";

	private static final boolean isRegularExpression(String s) {

		if (s.startsWith(PARENT_MESSAGE+MESSAGE_SEPARATOR))
			return isRegularExpression(s.substring((PARENT_MESSAGE +MESSAGE_SEPARATOR).length()));
		return (s.indexOf('*') != -1) || (s.indexOf('.') != -1)
				|| (s.indexOf('\\') != -1) || (s.indexOf('?') != -1)
				|| (s.indexOf('[') != -1) || (s.indexOf(']') != -1);

	}
}
