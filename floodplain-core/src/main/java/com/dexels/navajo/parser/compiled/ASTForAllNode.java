/* Generated By:JJTree&JavaCC: Do not edit this line. ASTForAllNode.java */

package com.dexels.navajo.parser.compiled;

import com.dexels.immutable.api.ImmutableMessage;
import com.dexels.immutable.api.ImmutableMessage.ValueType;
import com.dexels.navajo.document.NavajoException;
import com.dexels.navajo.document.operand.Operand;
import com.dexels.navajo.expression.api.ContextExpression;
import com.dexels.navajo.expression.api.FunctionClassification;
import com.dexels.navajo.expression.api.TMLExpressionException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;

final class ASTForAllNode extends SimpleNode {

    String functionName;
//    private Access access;

    ASTForAllNode(int id) {
        super(id);
    }

//    public Access getAccess() {
//        return access;
//    }
//
//    public void setAccess(Access access) {
//        this.access = access;
//    }


	@Override
	public ContextExpression interpretToLambda(List<String> problems, String expression, Function<String, FunctionClassification> functionClassifier, Function<String,Optional<Node>> mapResolver) {
		return new ContextExpression() {
			
			@Override
			public boolean isLiteral() {
				return false;
			}
			
			@Override
			public Operand apply(Optional<ImmutableMessage> immutableMessage, Optional<ImmutableMessage> paramMessage) {
				List<String> problems = new ArrayList<>();
				ContextExpression a = jjtGetChild(0).interpretToLambda(problems,expression,functionClassifier,mapResolver);
				ContextExpression b = jjtGetChild(1).interpretToLambda(problems,expression,functionClassifier,mapResolver);

				
				if(!problems.isEmpty()) {
					throw new TMLExpressionException(problems,expression);
				}
				return interpret(immutableMessage,paramMessage, a,b);
			}

			@Override
			public Optional<ValueType> returnType() {
				return Optional.empty();
			}
			
			@Override
			public String expression() {
				return expression;
			}
		};
	}
	
    /**
     * FORALL(<EXPRESSION>, `[$x] <EXPRESSION>`) E.G.
     * FORALL([/ClubMembership/ClubMemberships/ClubIdentifier],
     * `CheckRelatieCode([$x])`)
     * 
     * @return
     */
    private final Operand interpret(Optional<ImmutableMessage> immutableMessage, Optional<ImmutableMessage> paramMessage, ContextExpression a,ContextExpression b) {

        boolean matchAll = true;

        if (functionName.equals("FORALL"))
            matchAll = true;
        else
            matchAll = false;

        String msgList = (String) a.apply(immutableMessage,paramMessage).value;
        try {
            List<ImmutableMessage> list = immutableMessage.map(e->e.subMessages(msgList)).orElse(Optional.of(Collections.emptyList())).orElse(Collections.emptyList()); //.orElse(Collections.<ImmutableMessage>emptyList());


            for(ImmutableMessage o : list) {

                // ignore definition messages in the evaluation

                Operand apply = b.apply(immutableMessage,paramMessage);
				boolean result = (Boolean)apply.value;

                if ((!(result)) && matchAll)
                    return Operand.ofBoolean(false);
                if ((result) && !matchAll)
                    return Operand.ofBoolean(true);
            }

        } catch (NavajoException ne) {
            throw new TMLExpressionException("Invalid expression in FORALL construct: \n" + ne.getMessage());
        }
        return Operand.ofBoolean(matchAll); 
    }

}
